InstalledPackageInfo {
  sourcePackageId =
  PackageIdentifier {
    pkgName = PackageName
      "transformers",
    pkgVersion = mkVersion
      [0, 5, 2, 0]},
  sourceLibName = LMainLibName,
  installedComponentId_ =
  ComponentId "",
  libVisibility =
  LibraryVisibilityPublic,
  installedUnitId = UnitId
    "transformers-0.5.2.0",
  instantiatedWith = [],
  compatPackageKey =
  "transformers-0.5.2.0",
  license = Right BSD3,
  copyright = "",
  maintainer =
  "Ross Paterson <R.Paterson@city.ac.uk>",
  author =
  "Andy Gill, Ross Paterson",
  stability = "",
  homepage = "",
  pkgUrl = "",
  synopsis =
  "Concrete functor and monad transformers",
  description =
  concat
    [
      "A portable library of functor and monad transformers, inspired by\n",
      "the paper \\\"Functional Programming with Overloading and Higher-Order\n",
      "Polymorphism\\\", by Mark P Jones,\n",
      "in /Advanced School of Functional Programming/, 1995\n",
      "(<http://web.cecs.pdx.edu/~mpj/pubs/springschool.html>).\n",
      ".\n",
      "This package contains:\n",
      ".\n",
      "* the monad transformer class (in \"Control.Monad.Trans.Class\")\n",
      "and IO monad class (in \"Control.Monad.IO.Class\")\n",
      ".\n",
      "* concrete functor and monad transformers, each with associated\n",
      "operations and functions to lift operations associated with other\n",
      "transformers.\n",
      ".\n",
      "The package can be used on its own in portable Haskell code, in\n",
      "which case operations need to be manually lifted through transformer\n",
      "stacks (see \"Control.Monad.Trans.Class\" for some examples).\n",
      "Alternatively, it can be used with the non-portable monad classes in\n",
      "the @mtl@ or @monads-tf@ packages, which automatically lift operations\n",
      "introduced by monad transformers through other transformers."],
  category = "Control",
  abiHash = AbiHash
    "e04579c0363c9229351d1a0b394bf2d5",
  indefinite = False,
  exposed = True,
  exposedModules = [
    ExposedModule {
      exposedName = ModuleName
        "Control.Applicative.Backwards",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Applicative.Lift",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Signatures",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Class",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Cont",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Error",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Except",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Identity",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.List",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Maybe",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.RWS",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.RWS.Lazy",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.RWS.Strict",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Reader",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.State",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.State.Lazy",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.State.Strict",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Writer",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Writer.Lazy",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Control.Monad.Trans.Writer.Strict",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Data.Functor.Constant",
      exposedReexport = Nothing},
    ExposedModule {
      exposedName = ModuleName
        "Data.Functor.Reverse",
      exposedReexport = Nothing}],
  hiddenModules = [],
  trusted = False,
  importDirs = [
    "/opt/ghc/8.2.2/lib/ghc-8.2.2/transformers-0.5.2.0"],
  libraryDirs = [
    "/opt/ghc/8.2.2/lib/ghc-8.2.2/transformers-0.5.2.0"],
  libraryDirsStatic = [],
  libraryDynDirs = [
    "/opt/ghc/8.2.2/lib/ghc-8.2.2/transformers-0.5.2.0"],
  libraryBytecodeDirs = [],
  dataDir =
  "/opt/ghc/8.2.2/share/x86_64-linux-ghc-8.2.2/transformers-0.5.2.0",
  hsLibraries = [
    "HStransformers-0.5.2.0"],
  extraLibraries = [],
  extraLibrariesStatic = [],
  extraGHCiLibraries = [],
  includeDirs = [],
  includes = [],
  depends = [
    UnitId "base-4.10.1.0"],
  abiDepends = [
    AbiDependency {
      depUnitId = UnitId
        "base-4.10.1.0",
      depAbiHash = AbiHash
        "35a7f6be752ee4f7385cb5bf28677879"}],
  ccOptions = [],
  cxxOptions = [],
  ldOptions = [],
  frameworkDirs = [],
  frameworks = [],
  haddockInterfaces =
  [
    "/opt/ghc/8.2.2/share/doc/ghc-8.2.2/html/libraries/transformers-0.5.2.0/transformers.haddock"],
  haddockHTMLs = [
    "/opt/ghc/8.2.2/share/doc/ghc-8.2.2/html/libraries/transformers-0.5.2.0"],
  pkgRoot = Just
    "/opt/ghc/8.2.2/lib/ghc-8.2.2"}
