<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
    <!ENTITY Simple    '<ulink url="../libraries/Cabal/Distribution.Simple.html">Distribution.Simple</ulink>'>
    <!ENTITY Make      '<ulink url="../libraries/Cabal/Distribution.Make.html">Distribution.Make</ulink>'>
    <!ENTITY License   '<ulink url="../libraries/Cabal/Distribution.License.html#t:License"><literal>License</literal></ulink>'>
    <!ENTITY Extension '<ulink url="../libraries/Cabal/Distribution.Extension.html#t:Extension"><literal>Extension</literal></ulink>'>
    <!ENTITY Haddock '<ulink url="http://www.haskell.org/haddock/">Haddock</ulink>'>
  ]>

<article>
  <title>Common Architecture for Building Applications and Libraries</title>
  <subtitle>User's Guide</subtitle>

  <abstract>
    <para>The <firstterm>Cabal</firstterm> aims to simplify the
      distribution of Haskell software.  It does this by specifying a
      number of interfaces between package authors, builders and users,
      as well as providing a library implementing these interfaces.</para>
  </abstract>

  <sect1 id="packages">
    <title>Packages</title>

    <para>A <firstterm>package</firstterm> is the unit of distribution
      for the Cabal.  Its purpose, when installed, is to make available
      either or both of:</para>
    <itemizedlist>
      <listitem>
        <para>A library, exposing a number of Haskell modules.  A library
          may also contain <firstterm>hidden</firstterm> modules, which
          are used internally but not available to clients.<footnote>
            <para>Hugs doesn't support module hiding.</para>
          </footnote>
          </para>
      </listitem>

      <listitem>
        <para>One or more Haskell programs.</para>
      </listitem>
    </itemizedlist>
    <para>However having both a library and executables in a package
      does not work very well; if the executables depend on the library,
      they must explicitly list all the modules they directly or
      indirectly import from that library.</para>

    <para>Internally, the package may consist of much more than a
    bunch of Haskell modules: it may also have C source code and
    header files, source code meant for preprocessing, documentation,
    test cases, auxiliary tools etc.</para>

    <para>A package is identified by a globally-unique
      <firstterm>package name</firstterm>, an identifier containing
      no spaces. Chaos will result if two distinct packages with the
      same name are installed on the same system, but there is not
      yet a mechanism for allocating these names.
      A particular version of the package is distinguished by a
      <firstterm>version number</firstterm>, consisting of a sequence
      of one or more integers.  These can be combined to form a single
      text string called the <firstterm>package ID</firstterm>, using
      a hyphen to separate the version from the name, and dots to
      separate the version components, e.g.
      <quote><literal>HUnit-1.1</literal></quote>.</para>

    <note>
      <para>Packages are not part of the Haskell language;
        they simply populate the hierarchical space of module names.
        It is still the case that all the modules of a program must have
        distinct module names, regardless of the package they come from,
        and whether they are exposed or hidden.
        This also means that although some implementations (i.e. GHC) may
        allow several versions of a package to be installed at the same
        time, a program cannot use two packages, P and Q that depend
        on different versions of the same underlying package R.</para>
    </note>
  </sect1>

  <sect1 id="authors">
    <title>Creating a package</title>

    <para>Suppose you have a directory hierarchy containing the source
      files that make up your package.  You will need to add two more
      files to the root directory of the package:</para>
    <variablelist>
      <varlistentry>
        <term>
          <filename><replaceable>package</replaceable>.cabal</filename>
        </term>
        <listitem>
          <para>a text file containing a package description
            (for details of the syntax of this file, see
            <xref linkend="pkg-descr"/>), and</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <filename>Setup.hs</filename> or
          <filename>Setup.lhs</filename>
        </term>
        <listitem>
          <para>a single-module Haskell program to perform various
            setup tasks (with the interface described in
            <xref linkend="builders"/>).  This module should import only
            modules that will be present in all Haskell implementations,
            including modules of the Cabal library.  In most cases it
            will be trivial, calling on the Cabal library to do most of
            the work.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>Once you have these, you can create a source bundle of this
      directory for distribution.  Building of the package is discussed in
      <xref linkend="builders"/>.</para>

    <example id="simple-library-example">
      <title>A package containing a simple library</title>
      <para>The HUnit package contains a file <filename>HUnit.cabal</filename>
        containing:</para>
      <programlisting>
Name:           HUnit
Version:        1.1
License:        BSD3
Author:         Dean Herington
Homepage:       http://hunit.sourceforge.net/
Category:       Testing
Build-Depends:  base
Synopsis:       Unit testing framework for Haskell
Exposed-modules:
        Test.HUnit, Test.HUnit.Base, Test.HUnit.Lang,
        Test.HUnit.Terminal, Test.HUnit.Text
Extensions:     CPP</programlisting>
      <para>and the following <filename>Setup.hs</filename>:</para>
      <programlisting>
import Distribution.Simple
main = defaultMain</programlisting>
    </example>

    <example id="simple-executable-example">
      <title>A package containing executable programs</title>
      <programlisting>
Name:           TestPackage
Version:        0.0
License:        BSD3
Author:         Angela Author
Synopsis:       Small package with two programs
Build-Depends:  HUnit

Executable:     program1
Main-Is:        Main.hs
Hs-Source-Dir:  prog1

Executable:     program2
Main-Is:        Main.hs
Hs-Source-Dir:  prog2
Other-Modules:  Utils</programlisting>
      <para>with <filename>Setup.hs</filename> the same as above.</para>
    </example>

    <example id="simple-library-executable-example">
      <title>A package containing a library and executable programs</title>
      <programlisting>
Name:            TestPackage
Version:         0.0
License:         BSD3
Author:          Angela Author
Synopsis:        Package with library and two programs
Build-Depends:   HUnit
Exposed-Modules: A, B, C

Executable:      program1
Main-Is:         Main.hs
Hs-Source-Dir:   prog1
Other-Modules:   A, B

Executable:      program2
Main-Is:         Main.hs
Hs-Source-Dir:   prog2
Other-Modules:   A, C, Utils</programlisting>
      <para>with <filename>Setup.hs</filename> the same as above.</para>
    </example>

    <para>The trivial setup script used in these examples uses
      the <firstterm>simple build infrastructure</firstterm>
      provided by the Cabal library (see &Simple;).
      The simplicity lies in its interface rather that its implementation.
      It automatically handles preprocessing with standard preprocessors,
      and builds packages for all the Haskell implementations (except
      nhc98, for now).</para>

    <para>The simple build infrastructure can also handle packages
      where building is governed by system-dependent parameters,
      if you specify a little more (see <xref linkend="system-dependent"/>).
      A few packages require more elaborate solutions
      (see <xref linkend="complex-packages"/>).</para>

    <sect2 id="pkg-descr">
      <title>Package descriptions</title>

      <para>The package description file should have a name ending in
        <quote><literal>.cabal</literal></quote>.  There must be exactly
        one such file in the directory, and the first part of the name is
        immaterial, but it is conventional to use the package name.</para>

      <para>This file should contain several
        <firstterm>stanzas</firstterm> separated by blank lines.
        Each stanza consists of a number of field/value pairs, with a
        syntax like mail message headers.</para>
      <itemizedlist>
	<listitem>
          <para>case is not significant in field names</para>
	</listitem>
	<listitem>
          <para>to continue a field value, indent the next line</para>
	</listitem>
	<listitem>
          <para>to get a blank line in a field value, use an indented
            <quote><literal>.</literal></quote></para>
	</listitem>
      </itemizedlist>
      <para>Lines beginning with <quote><literal>--</literal></quote>
        are treated as comments and ignored.</para>

      <para>The syntax of the value depends on the field.  Field types
        include:</para>

      <variablelist>
        <varlistentry>
          <term>
            <replaceable>token</replaceable>
          </term>
          <term>
            <replaceable>filename</replaceable>
          </term>
          <term>
            <replaceable>directory</replaceable>
          </term>
          <listitem>
            <para>Either a sequence of one or more non-space non-comma
              characters, or a quoted string in Haskell 98 lexical syntax.
              Unless otherwise stated, relative filenames and directories
              are interpreted from the package root directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <replaceable>freeform</replaceable>
          </term>
          <term>
            <replaceable>URL</replaceable>
          </term>
          <term>
            <replaceable>address</replaceable>
          </term>
          <listitem>
            <para>An arbitrary, uninterpreted string.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <replaceable>identifier</replaceable>
          </term>
          <listitem>
            <para>A letter followed by zero or more alphanumerics
              or underscores.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Some fields take lists of values, which
        are optionally separated by commas, except for the
        <literal>build-depends</literal> field, where the commas are
        mandatory.</para>

      <para>Some fields are marked as required.  All others are optional,
        and unless otherwise specified have empty default values.</para>

      <para>The first stanza describes the package
        as a whole, as well as the library it contains (if any), using
        the following fields:</para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>name:</literal> <replaceable>identifier</replaceable>
            (required)
          </term>
          <listitem>
            <para>The unique name of the package, without the version
              number.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>version:</literal> <replaceable>numbers</replaceable>
            (required)
          </term>
          <listitem>
            <para>The package version number, usually consisting of a
              sequence of natural numbers separated by dots.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>license:</literal> <replaceable>identifier</replaceable>
            (default: <literal>AllRightsReserved</literal>)
          </term>
          <listitem>
            <para>The type of license under which this package is distributed.
              License names are the constants of the &License; type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>license-file:</literal>
            <replaceable>filename</replaceable>
          </term>
          <listitem>
            <para>The name of a file containing the precise license for
              this package.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>copyright:</literal>
            <replaceable>freeform</replaceable>
          </term>
          <listitem>
            <para>The content of a copyright notice, typically the name of
              the holder of the copyright on the package and the year(s)
              from which copyright is claimed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>author:</literal>
            <replaceable>freeform</replaceable>
          </term>
          <listitem>
            <para>The original author of the package.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>maintainer:</literal>
            <replaceable>address</replaceable>
          </term>
          <listitem>
            <para>The current maintainer or maintainers of the package.
              This is an e-mail address to which users should send bug
              reports, feature requests and patches.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>stability:</literal>
            <replaceable>freeform</replaceable>
          </term>
          <listitem>
            <para>The stability level of the package, e.g.
              <literal>alpha</literal>, <literal>experimental</literal>,
              <literal>provisional</literal>, <literal>stable</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>homepage:</literal> <replaceable>URL</replaceable>
          </term>
          <listitem>
            <para>The package homepage.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>package-url:</literal> <replaceable>URL</replaceable>
          </term>
          <listitem>
            <para>The location of a source bundle for the package.
              The distribution should be a Cabal package.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>synopsis:</literal>
            <replaceable>freeform</replaceable>
          </term>
          <listitem>
            <para>A very short description of the package, for use in a
              table of packages.  This is your headline, so keep it short
              (one line) but as informative as possible.  Save space
              by not including the package name or saying it's written
              in Haskell.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>description:</literal>
            <replaceable>freeform</replaceable>
          </term>
          <listitem>
            <para>Description of the package.  This may be several
              paragraphs, and should be aimed at a Haskell programmer
              who has never heard of your package before.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>category:</literal>
            <replaceable>freeform</replaceable>
          </term>
          <listitem>
            <para>A classification category for future use by the package
              catalogue <firstterm>Hackage</firstterm>.  These categories
              have not yet been specified, but the upper levels of the
              module hierarchy make a good start.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>tested-with:</literal>
            <replaceable>compiler list</replaceable>
          </term>
          <listitem>
            <para>A list of compilers and versions against which the
              package has been tested (or at least built).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>build-depends:</literal>
            <replaceable>package list</replaceable>
          </term>
          <listitem>
            <para>A list of packages, possibly annotated with versions,
              needed to build this one, e.g. <literal>foo > 1.2, bar</literal>.
              If no version constraint is specified, any version is assumed
              to be acceptable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>exposed-modules:</literal>
            <replaceable>identifier list</replaceable>
            (required if this package contains a library)
          </term>
          <listitem>
            <para>A list of modules added by this package.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>Module names may correspond to Haskell source files, i.e.
          with names ending in <quote><literal>.hs</literal></quote>
          or <quote><literal>.lhs</literal></quote>, or to inputs for
          various Haskell preprocessors.  The simple build infrastructure
          understands
          <quote><literal>.gc</literal></quote> (GreenCard),
          <quote><literal>.chs</literal></quote> (<command>c2hs</command>),
          <quote><literal>.hsc</literal></quote> (<command>hsc2hs</command>),
          <quote><literal>.y</literal></quote> and
          <quote><literal>.ly</literal></quote> (<command>happy</command>),
          <quote><literal>.x</literal></quote> (<command>alex</command>)
          and
          <quote><literal>.cpphs</literal></quote> (<command>cpphs</command>).
          In such cases the appropriate preprocessor will be run
          automatically as required.</para>
      </note>

      <para>This stanza may also contain build information fields
        (see <xref linkend="buildinfo"/>) relating to the library.</para>

      <section id="executable">
        <title>Executables</title>

        <para>Subsequent stanzas (if present) describe executable programs
          contained in the package, using the following fields, as well as
          build information fields (see <xref linkend="buildinfo"/>).</para>

        <variablelist>
          <varlistentry>
            <term>
              <literal>executable:</literal>
              <replaceable>freeform</replaceable>
              (required)
            </term>
            <listitem>
              <para>The name of the executable program.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>main-is:</literal> <replaceable>filename</replaceable>
              (required)
            </term>
            <listitem>
              <para>The name of the source file containing the
                <literal>Main</literal> module, relative to the
                <literal>hs-source-dir</literal> directory.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="buildinfo">
        <title>Build information</title>

        <para>The following fields may be optionally present
          in any stanza, and give information for the building
          of the corresponding library or executable.  See also
          <xref linkend="system-dependent"/> for a way to supply
          system-dependent values for these fields.</para>

        <variablelist>
          <varlistentry>
            <term>
              <literal>buildable:</literal> <replaceable>Boolean</replaceable>
              (default: <literal>True</literal>)
            </term>
            <listitem>
              <para>Is the component buildable?
                Like some of the other fields below, this field is
                more useful with the slightly more elaborate form of
                the simple build infrastructure described in
                <xref linkend="system-dependent"/>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>other-modules:</literal>
              <replaceable>identifier list</replaceable>
            </term>
            <listitem>
              <para>A list of modules used by the component
                but not exposed to users.  For a library component, these
                would be hidden modules of the library.  For an executable,
                these would be auxiliary modules to be linked with the
                file named in the <literal>main-is</literal> field.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>hs-source-dir:</literal>
              <replaceable>directory</replaceable>
              (default: <quote><literal>.</literal></quote>)
            </term>
            <listitem>
              <para>The name of root directory of the module
                hierarchy.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <literal>extensions:</literal>
              <replaceable>identifier list</replaceable>
            </term>
            <listitem>
              <para>A list of Haskell extensions used by every module.
                Extension names are the constructors of the &Extension; type.
                These determine corresponding compiler options.
                In particular, <literal>CPP</literal> specifies that
                Haskell source files are to be preprocessed with a
                C preprocessor.</para>

              <para>Extensions used only by one module may be specified
                by placing a <literal>LANGUAGE</literal> pragma in the
                source file affected, e.g.:</para>
                <programlisting>{-# LANGUAGE CPP, MultiParamTypeClasses #-}</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>ghc-options:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>Additional options for GHC.  You can often achieve
                the same effect using the <literal>extensions</literal>
                field, which is preferred.</para>

              <para>Options required only by one module may be specified
                by placing an <literal>OPTIONS_GHC</literal> pragma in the
                source file affected.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>hugs-options:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>Additional options for Hugs.  You can often achieve
                the same effect using the <literal>extensions</literal>
                field, which is preferred.</para>

              <para>Options required only by one module may be specified
                by placing an <literal>OPTIONS_HUGS</literal> pragma in the
                source file affected.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>nhc-options:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>Additional options for nhc98.  You can often achieve
                the same effect using the <literal>extensions</literal>
                field, which is preferred.</para>

              <para>Options required only by one module may be specified
                by placing an <literal>OPTIONS_NHC</literal> pragma in the
                source file affected.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>includes:</literal>
              <replaceable>filename list</replaceable>
            </term>
            <listitem>
              <para>A list of header files from standard
                include directories or those listed in
                <literal>include-dirs</literal>, to be included in any
                compilations via C.  These files typically contain
                function prototypes for foreign imports used by the
                package.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>include-dirs:</literal>
              <replaceable>directory list</replaceable>
            </term>
            <listitem>
              <para>A list of directories to search for header files,
                both when using a C preprocessor and when compiling
                via C.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>c-sources:</literal>
              <replaceable>filename list</replaceable>
            </term>
            <listitem>
              <para>A list of C source files to be compiled
                and linked with the Haskell files.</para>

              <para>If you use this field, you should also name the
                C files in <literal>CFILES</literal> pragmas in the
                Haskell source files that use them, e.g.:
                <screen>{-# CFILES dir/file1.c dir/file2.c #-}</screen>
                These are ignored by the compilers, but needed by Hugs.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>extra-libraries:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>A list of extra libraries to link with.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>extra-lib-dirs:</literal>
              <replaceable>directory list</replaceable>
            </term>
            <listitem>
              <para>A list of directories to search for libraries.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>cc-options:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>Command-line arguments to be passed to the C compiler.
                Since the arguments are compiler-dependent, this field
                is more useful with the setup described in
                <xref linkend="system-dependent"/>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>ld-options:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>Command-line arguments to be passed to the linker.
                Since the arguments are compiler-dependent, this field
                is more useful with the setup described in
                <xref linkend="system-dependent"/>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <literal>frameworks:</literal>
              <replaceable>token list</replaceable>
            </term>
            <listitem>
              <para>On Darwin/MacOS X, a list of frameworks to link to.
                See Apple's developer documentation for more details
                on frameworks.  This entry is ignored on all other
                platforms.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </sect2>

    <sect2 id="system-dependent">
      <title>System-dependent parameters</title>

      <para>For some packages, implementation details and the build
        procedure depend on the build environment.  The simple build
        infrastructure can handle many such situations using a slightly
        longer <filename>Setup.hs</filename>:</para>
      <programlisting>
import Distribution.Simple
main = defaultMainWithHooks defaultUserHooks</programlisting>

      <para>This program differs from <literal>defaultMain</literal>
        in two ways:</para>
      <orderedlist>
        <listitem>
          <para>If the package root directory contains a file called
            <filename>configure</filename>, the configure step will
            run that.  This <filename>configure</filename> program may
            be a script produced by the <command>autoconf</command>
            system, or may be hand-written.  This program typically
            discovers information about the system and records it for
            later steps, e.g. by generating system-dependent header files
            for inclusion in C source files and preprocessed Haskell
            source files.  (Clearly this won't work for Windows without
            MSYS or Cygwin: other ideas are needed.)</para>
        </listitem>

        <listitem>
          <para>If the package root directory contains a file called
            <replaceable>package</replaceable><literal>.buildinfo</literal>
            after the configuration step, subsequent steps will read it
            to obtain additional settings for build information fields
            (see <xref linkend="buildinfo"/>), to be merged with the
            ones given in the <literal>.cabal</literal> file.
            In particular, this file may be generated by the
            <filename>configure</filename> script mentioned above,
            allowing these settings to vary depending on the build
            environment.</para>

          <para>The build information file should have the following
            structure:</para>
          <programlisting>
<replaceable>buildinfo</replaceable>

executable: <replaceable>name</replaceable>
<replaceable>buildinfo</replaceable>

executable: <replaceable>name</replaceable>
<replaceable>buildinfo</replaceable>

...</programlisting>
          <para>where each <replaceable>buildinfo</replaceable> consists
            of settings of fields listed in <xref linkend="buildinfo"/>.
            The first one (if present) relates to the library, while each
            of the others relate to the named executable.  (The names
            must match the package description, but you don't have to
            have entries for all of them.)</para>

        </listitem>
      </orderedlist>

      <para>Neither of these files is required.  If they are absent, this
        setup script is equivalent to <literal>defaultMain</literal>.</para>

      <example>
        <title>Using autoconf</title>

        <para>(This example is for people familiar with the autoconf
          tools.)</para>

        <para>In the X11 package, the file <filename>configure.ac</filename>
          contains:</para>
        <programlisting>
AC_INIT([Haskell X11 package], [1.1], [libraries@haskell.org], [X11])

# Safety check: Ensure that we are in the correct source directory.
AC_CONFIG_SRCDIR([X11.cabal])

# Header file to place defines in
AC_CONFIG_HEADERS([include/HsX11Config.h])

# Check for X11 include paths and libraries
AC_PATH_XTRA
AC_TRY_CPP([#include &lt;X11/Xlib.h&gt;],,[no_x=yes])

# Build the package if we found X11 stuff
if test "$no_x" = yes
then BUILD_PACKAGE_BOOL=False
else BUILD_PACKAGE_BOOL=True
fi
AC_SUBST([BUILD_PACKAGE_BOOL])

AC_CONFIG_FILES([X11.buildinfo])
AC_OUTPUT</programlisting>

        <para>Then the setup script will run the
          <literal>configure</literal> script, which checks for the
          presence of the X11 libraries and substitutes for variables
          in the file <filename>X11.buildinfo.in</filename>:</para>
        <programlisting>
buildable: @BUILD_PACKAGE_BOOL@
cc-options: @X_CFLAGS@
ld-options: @X_LIBS@</programlisting>

        <para>This generates a file <filename>X11.buildinfo</filename>
          supplying the parameters needed by later stages:</para>
        <programlisting>
buildable: True
cc-options:  -I/usr/X11R6/include
ld-options:  -L/usr/X11R6/lib</programlisting>

        <para>The <filename>configure</filename> script also generates
          a header file <filename>include/HsX11Config.h</filename>
          containing C preprocessor defines recording the results of
          various tests.  This file may be included by C source files
          and preprocessed Haskell source files in the package.</para>
      </example>
    </sect2>

    <sect2 id="complex-packages">
      <title>More complex packages</title>

      <para>For packages that don't fit the simple schemes described above,
        you have a few options:</para>

      <itemizedlist>
        <listitem>
          <para>You can customize the simple build infrastructure using
            <firstterm>hooks</firstterm>.  These allow you to perform
            additional actions before and after each command is run,
            and also to specify additional preprocessors.  See &Simple;
            for the details, but note that this interface is experimental,
            and likely to change in future releases..</para>
        </listitem>

        <listitem>
          <para>You could delegate all the work to <command>make</command>,
            though this is unlikely to be very portable.
            Cabal supports this with a trivial setup library &Make;,
            which simply parses the command line arguments and invokes
            <command>make</command>.  Here <filename>Setup.hs</filename>
            looks like</para>
          <programlisting>
import Distribution.Make
main = defaultMain</programlisting>

          <para>The root directory of the package should contain
            a <filename>configure</filename> script, and, after
            that has run, a <filename>Makefile</filename> with a
            default target that builds the package, plus targets
            <literal>install</literal>, <literal>register</literal>,
            <literal>unregister</literal>, <literal>clean</literal>,
            <literal>dist</literal> and <literal>docs</literal>.
            Some options to commands are passed through as follows:</para>

          <itemizedlist>
            <listitem>
              <para>The <literal>--with-hc</literal>,
                <literal>--with-hc-pkg</literal> and
                <literal>--prefix</literal> options to the
                <literal>configure</literal> command are passed on to
                the <filename>configure</filename> script.</para>
            </listitem>

            <listitem>
              <para>the <literal>--copy-prefix</literal> option to the
                <literal>copy</literal> command becomes a setting of a
                <literal>prefix</literal> variable on the invocation of
                <literal>make install</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>You can write your own setup script conforming to the
            interface of <xref linkend="builders"/>, possibly using the
            Cabal library for part of the work.  One option is to copy the
            source of Distribution.Simple, and alter it for your needs.
            Good luck.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="builders">
    <title>Building and installing a package</title>
    <para>After you've unpacked a Cabal package, you can build it
      by moving into the root directory of the package and using the
      <filename>Setup.hs</filename> or <filename>Setup.lhs</filename>
      script there:</para>
    <cmdsynopsis>
      <command>runhaskell Setup.hs</command>
      <arg><replaceable>command</replaceable></arg>
      <arg rep="repeat" choice="opt"><replaceable>option</replaceable></arg>
    </cmdsynopsis>
    <para>where <literal>runhaskell</literal> might be
      <literal>runhugs</literal>, <literal>runghc</literal> or
      <literal>runnhc</literal>.  The <replaceable>command</replaceable>
      argument selects a particular step in the build/install process.
      You can also get a summary of the command syntax with</para>
    <cmdsynopsis>
      <command>runhaskell Setup.hs <option>--help</option></command>
    </cmdsynopsis>

    <example>
      <title>Building and installing a system package</title>
      <screen>
runhaskell Setup.hs configure --ghc
runhaskell Setup.hs build
runhaskell Setup.hs install</screen>
      <para>The first line readies the system to build the tool using GHC;
        for example, it checks that GHC exists on the system.  The second
        line performs the actual building, while the last both copies
        the build results to some permanent place and registers the
        package with GHC.</para>
    </example>

    <example>
      <title>Building and installing a user package</title>
      <screen>
runhaskell Setup.hs configure --ghc --prefix=$HOME
runhaskell Setup.hs build
runhaskell Setup.hs install --user</screen>
      <para>In this case, since the package will be registered in the
        user's package database, we also install it under the user's
        home directory.</para>
    </example>

    <example>
      <title>Creating a binary package</title>
      <para>When creating binary packages (e.g. for RedHat or
        Debian) one needs to create a tarball that can be sent to
        another system for unpacking in the root directory:</para>
      <screen>
runhaskell Setup.hs configure --ghc --prefix=/usr
runhaskell Setup.hs build
runhaskell Setup.hs copy --copy-prefix=/tmp/mypkg/usr
(cd /tmp/mypkg; tar cf - .) | gzip -9 >mypkg.tar.gz</screen>

      <para>If the package contains a library, you need two additional
        steps:</para>
      <screen>
runhaskell Setup.hs register --gen-script
runhaskell Setup.hs unregister --gen-script</screen>
      <para>This creates shell scripts <filename>register.sh</filename>
        and <filename>unregister.sh</filename>, which must also be sent
        to the target system.  After unpacking there, the package must be
        registered by running the <filename>register.sh</filename> script.
        The <filename>unregister.sh</filename> script would be used
        in the uninstall procedure of the package.  Similar steps may
        be used for creating binary packages for Windows.</para>
    </example>

    <para>The following options are understood by all commands:</para>
    <variablelist>
      <varlistentry>
        <term>
          <option>--help</option>, <option>-h</option> or
          <option>-?</option>
        </term>
        <listitem>
          <para>List the available options for the command.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>--verbose</option>=<replaceable>n</replaceable> or
          <option>-v</option><replaceable>n</replaceable>
        </term>
        <listitem>
          <para>Set the verbosity level (0-5).  The normal level is 1;
            a missing <replaceable>n</replaceable> defaults to 3.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The various commands and the additional options they support
      are described below.  In the simple build infrastructure, any
      other options will be reported as errors, except in the case of
      the <literal>configure</literal> command.</para>

    <sect2>
      <title>setup configure</title>
      <para>Prepare to build the package.
        Typically, this step checks that the target platform is capable
        of building the package, and discovers platform-specific features
        that are needed during the build.  In addition to the general
        options, this command recognizes the following</para>

      <variablelist>
        <varlistentry>
          <term><option>--prefix</option>=<replaceable>dir</replaceable></term>
          <listitem>
            <para>Specify the installation prefix
              (default: <filename>/usr/local</filename> on Unix systems).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--ghc</option> or <option>-g</option></term>
          <term><option>--nhc</option> or <option>-n</option></term>
          <term><option>--hugs</option></term>
          <listitem>
            <para>Specify which Haskell implementation to use to build
              the package.  At most one of these flags may be given.
              If none is given, the implementation under which the setup
              script was compiled or interpreted is used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-compiler</option>=<replaceable>path</replaceable>
  	  or <option>-w</option><replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to a particular compiler.  If given,
              this must match the implementation selected above.
              The default is to search for the usual name of the
              selected implementation.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-hc-pkg</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to the package tool, e.g.
              <literal>ghc-pkg</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-haddock</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to &Haddock;.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-happy</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to <command>happy</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-alex</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to <command>alex</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-hsc2hs</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to <command>hsc2hs</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-cpphs</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the path to <command>cpphs</command>.</para>
          </listitem>
        </varlistentry>

	<varlistentry>
	  <term><option>--user</option></term>
	  <listitem>
	    <para>Allow dependencies to be satisfied by the user package
	      database, in addition to the global database.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--global</option></term>
	  <listitem>
	    <para>(default) Dependencies must be satisfied by the global
	      package database.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>In the simple build infrastructure, an additional option
        is recognized:</para>
      <variablelist>
        <varlistentry>
          <term><option>--builddir</option>=<replaceable>dir</replaceable> or
            <option>-b</option><replaceable>dir</replaceable></term>
          <listitem>
            <para>Specify the directory into which the package will be
              built (default: <filename>dist/build</filename>).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>In the simple build infrastructure, the values supplied via
        these options are recorded in a private file for use by later
        stages.</para>

      <para>If a user-supplied <filename>configure</filename> script is
        run (see <xref linkend="system-dependent"/>), it is passed the
        <option>--prefix</option> option and any unrecognized options.</para>

    </sect2>

    <sect2>
      <title>setup build</title>
      <para>Perform any preprocessing or compilation needed to make this
        package ready for installation.</para>
    </sect2>

    <sect2>
      <title>setup haddock</title>
      <para>Build the interface documentation for a library using
        &Haddock;.</para>
    </sect2>

    <sect2>
      <title>setup install</title>
      <para>Copy the files into the install locations and (for library
        packages) register the package with the compiler, i.e. make the
        modules it contains available to programs.</para>

      <para>This command takes the following options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--global</option></term>
          <listitem>
            <para>Register this package in the system-wide database.
              (This is the default.)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--user</option></term>
          <listitem>
            <para>Register this package in the user's local package
              database.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>setup copy</title>
      <para>Copy the files without registering them.  This command
        is mainly of use to those creating binary packages.</para>

      <para>This command takes the following option:</para>

      <variablelist>
        <varlistentry>
          <term><option>--copy-prefix</option>=<replaceable>path</replaceable></term>
          <listitem>
            <para>Specify the directory under which to place
              installed files.  If this is not given, the
              argument of the <option>--prefix</option> option to
              <literal>configure</literal> is used.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>setup register</title>
      <para>Register this package with the compiler, i.e. make the
        modules it contains available to programs.  This only makes sense
        for library packages.  Note that the <literal>install</literal>
        command incorporates this action.  The main use of this
        separate command is in the post-installation step for a binary
        package.</para>

      <para>This command takes the following options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--global</option></term>
          <listitem>
            <para>Register this package in the system-wide database.
              (This is the default.)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--user</option></term>
          <listitem>
            <para>Register this package in the user's local package
              database.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--gen-script</option></term>
          <listitem>
            <para>Instead of registering the package, generate a script
              containing commands to perform the registration.  On Unix,
              this file is called <filename>register.sh</filename>, on
              Windows, <filename>register.bat</filename>.  This script
              might be included in a binary bundle, to be run after the
              bundle is unpacked on the target system.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>setup unregister</title>
      <para>Deregister this package with the compiler.</para>

      <para>This command takes the following options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--global</option></term>
          <listitem>
            <para>Deregister this package in the system-wide database.
              (This is the default.)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--user</option></term>
          <listitem>
            <para>Deregister this package in the user's local package
              database.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--gen-script</option></term>
          <listitem>
            <para>Instead of deregistering the package, generate a script
              containing commands to perform the deregistration.  On Unix,
              this file is called <filename>unregister.sh</filename>, on
              Windows, <filename>unregister.bat</filename>.  This script
              might be included in a binary bundle, to be run on the
              target system.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>setup clean</title>
      <para>Remove any files created during the configure or build
        steps.</para>
    </sect2>

    <sect2>
      <title>setup sdist</title>
      <para>Create a system- and compiler-independent source distribution
        in a file
        <filename><replaceable>package</replaceable>-<replaceable>version</replaceable>.tgz</filename>
        that can be distributed to package builders.  When unpacked,
        the commands listed in this section will be available.</para>

      <para>However this command is not yet working in the simple build
        infrastructure.</para>
    </sect2>
  </sect1>

  <sect1 id="bugs">
    <title>Known bugs and deficiencies</title>

    <para>All these should be fixed in future versions:</para>

    <itemizedlist>
      <listitem>
        <para>In the simple build infrastructure, the
          <literal>sdist</literal> command does not work.</para>
      </listitem>

      <listitem>
        <para>The scheme described in <xref linkend="system-dependent"/>
          will not work on Windows without MSYS or Cygwin.</para>
      </listitem>

      <listitem>
        <para>Cabal has some limitations both running under Hugs
          and building packages for it:</para>
        <itemizedlist>
          <listitem>
            <para>Cabal does not work with the current stable release
              (Nov 2003), just the development version.</para>
          </listitem>

          <listitem>
            <para>It doesn't work with Windows.</para>
          </listitem>

          <listitem>
            <para>The <option>--user</option> option is unavailable.</para>
          </listitem>

          <listitem>
            <para>There is no <literal>hugs-pkg</literal> tool.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Though the library runs under Nhc98, it cannot build
          packages for Nhc98.</para>
      </listitem>

    </itemizedlist>

    <para>Please report any other flaws to
      <email>libraries@haskell.org</email>.</para>
  </sect1>

</article>
