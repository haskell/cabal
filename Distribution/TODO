* Documentation
** Integrate SimonPJ's document into the "proposal" (simonpj)
** x-pkg command-line interface

* Code
** configure step
** cross-platform compiler location(simonmar?)
** help action without command... help command?
** build
** install
** register
** generate InstalledPackageInfo
** read & write config-droppings

* later todo
** command-line parsing errors

* Testing
** error cases for parsing command-line args
** reading & writing configuration-dropping

** use-cases based on SimonPJ's doc
** discovering the location of the given flavor of compiler and pkg tool

* Isaac
-- difference bt flags and opts...

------------------------------------------------------------
* Setup Command-line interface
** Actions
- build
- install (+maybe installprefix, maybe system)
- configure (+flags)
- packageinfo
- sdist
- register (maybe system)
- unregister (maybe system)

** flags
--help
--ghc
--nhc
--hugs
--with-compiler=
--prefix=
--instprefix=
--help (for compatibility? it's really more of an action)

* 1.0
** actions
- bdist
- clean
- doc stuff?

** flags
--hbc
--helium
--with-compiler=



------------------------------------------------------------

* Priorities for first beta release
(basically what was in SPJ's document):

** Basic command-line interface for configure, build, install,
   register, unregister, info
** Ability to wrap make
** basic build system (think hmake)
** binary distributions?

* Priorities for 1.0
** binary distributions?
** basic pre-processor extensions
** hat support
** haddock support
** user use configuration vs system use configuration

* looking ahead
** per-system source database
** rebuild for new compiler

* Orthogonal (layered?) tools

** visual studio support

** public database of packages

** downloadable public database of packages (wget filename;tar xf
   filename;cd filename;./setup install)

   NOTE: such an interface might be implemented w/ xml-rpc, which is
   there for Haskell now, though in general we'll probabliy want to be
   careful here about dependencies.

** debian package building (boilerplate) tool.  Other debian support
   w/ rebuild-all-packages?

groupAllBy :: (a -> a -> Bool) -> [a] -> [[a]]
groupAllBy fun (h:t)
    = let (groups, rem') = (partition (fun h) t)
          in if null groups
             then [h]:(groupAllBy fun rem')
             else (h:groups):(groupAllBy fun rem')
groupAllBy _ [] = []
                                                                                
                                                                                
