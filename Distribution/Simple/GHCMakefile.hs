-- DO NOT EDIT: change GHCMakefile.in, and run ../../mkGHCMakefile.sh
module Distribution.Simple.GHCMakefile where{ makefileTemplate=
"# -----------------------------------------------------------------------------\n# Makefile template starts here.\n\nGHC_OPTS += -i$(odir)\n\n# For adding options on the command-line\nGHC_OPTS += $(EXTRA_HC_OPTS)\n\nWAY_p_OPTS = -prof\n\nifneq \"$(way)\" \"\"\nway_ := $(way)_\n_way := _$(way)\nGHC_OPTS += $(WAY_$(way)_OPTS)\nGHC_OPTS += -hisuf $(way_)hi -hcsuf $(way_)hc -osuf $(osuf)\nendif\nosuf  = $(way_)o\nhisuf = $(way_)hi\n\nHS_OBJS = $(patsubst %,$(odir)/%.$(osuf),$(subst .,/,$(modules)))\nHS_IFS  = $(patsubst %,$(odir)/%.$(hisuf),$(subst .,/,$(modules)))\nC_OBJS  = $(patsubst %.c,$(odir)/%.$(osuf),$(C_SRCS))\n\nLIB = $(odir)/libHS$(package)$(_way).a\n\nSTUBOBJS = $(wildcard $(patsubst %.$(osuf), %_stub.$(osuf), $(HS_OBJS)))\n\nall :: .depend $(LIB)\n\n.depend : $(MAKEFILE)\n\t$(GHC) -M -optdep-f -optdep.depend $(foreach way,$(WAYS),-optdep-s -optdep$(way)) $(foreach obj,$(MKDEPENDHS_OBJ_SUFFICES),-osuf $(obj)) $(filter-out -split-objs, $(GHC_OPTS)) $(modules)\n\tfor dir in $(sort $(foreach mod,$(HS_OBJS) $(C_OBJS),$(dir $(mod)))); do \\\n\t\tif test ! -d $$dir; then mkdir -p $$dir; fi \\\n\tdone\n\ninclude .depend\n\nifneq \"$(filter -split-objs, $(GHC_OPTS))\" \"\"\n$(LIB) : $(HS_OBJS) $(C_OBJS)\n\t(echo $(STUBOBJS) $(C_OBJS); find $(patsubst %.$(osuf),%_split,$(HS_OBJS)) -name '*.$(way_)o' -print) | xargs -s 30000 $(AR) q $(EXTRA_AR_ARGS) $@ \nelse\n$(LIB) : $(HS_OBJS) $(C_OBJS)\n\techo $(STUBOBJS) $(C_OBJS) $(HS_OBJS) | xargs -s 30000 $(AR) q $(EXTRA_AR_ARGS) $@ \nendif\n\nifneq \"$(GHCI_LIB)\" \"\"\nifeq \"$(way)\" \"\"\nall ::  $(GHCI_LIB)\n\n$(GHCI_LIB) : $(HS_OBJS) $(C_OBJS)\n\t@$(RM) $@\n\t$(LD) -r -x -o $@ $(EXTRA_LD_OPTS) $(HS_OBJS) $(STUBOBJS) $(C_OBJS)\nendif\nendif\n\n# suffix rules\n\nifneq \"$(odir)\" \"\"\nodir_ = $(odir)/\nelse\nodir_ =\nendif\n\n$(odir_)%.$(osuf) : $(srcdir)/%.hs\n\t$(GHC) $(GHC_OPTS) -c $< -o $@  -ohi $(basename $@).$(hisuf)\n\n$(odir_)%.$(osuf) : $(srcdir)/%.lhs\t \n\t$(GHC) $(GHC_OPTS) -c $< -o $@  -ohi $(basename $@).$(hisuf)\n\n# The .hs files might be in $(odir) if they were preprocessed\n$(odir_)%.$(osuf) : $(odir_)%.hs\n\t$(GHC) $(GHC_OPTS) -c $< -o $@  -ohi $(basename $@).$(hisuf)\n\n$(odir_)%.$(osuf) : $(odir_)%.lhs\n\t$(GHC) $(GHC_OPTS) -c $< -o $@  -ohi $(basename $@).$(hisuf)\n\n$(odir_)%.$(osuf) : $(srcdir)/%.c\n\t@$(RM) $@\n\t$(GHC) $(GHC_CC_OPTS) -c $< -o $@\n\n$(odir_)%.$(osuf) : $(srcdir)/%.$(way_)s\n\t@$(RM) $@\n\t$(GHC) $(GHC_CC_OPTS) -c $< -o $@\n\n$(odir_)%.$(osuf) : $(srcdir)/%.S\n\t@$(RM) $@\n\t$(GHC) $(GHC_CC_OPTS) -c $< -o $@\n\n$(odir_)%.$(way_)s : $(srcdir)/%.c\n\t@$(RM) $@\n\t$(GHC) $(GHC_CC_OPTS) -S $< -o $@\n\n$(odir_)%.$(osuf)-boot : $(srcdir)/%.hs-boot\n\t$(GHC) $(GHC_OPTS) -c $< -o $@ -ohi $(basename $@).$(way_)hi-boot\n\n$(odir_)%.$(osuf)-boot : $(srcdir)/%.lhs-boot\n\t$(GHC) $(GHC_OPTS) -c $< -o $@ -ohi $(basename $@).$(way_)hi-boot\n\n%.$(hisuf) : %.$(osuf)\n\t@if [ ! -f $@ ] ; then \\\n\t    echo Panic! $< exists, but $@ does not.; \\\n\t    exit 1; \\\n\telse exit 0 ; \\\n\tfi\n\n%.$(way_)hi-boot : %.$(osuf)-boot\n\t@if [ ! -f $@ ] ; then \\\n\t    echo Panic! $< exists, but $@ does not.; \\\n\t    exit 1; \\\n\telse exit 0 ; \\\n\tfi\n\n$(odir_)%.$(hisuf) : %.$(way_)hc\n\t@if [ ! -f $@ ] ; then \\\n\t    echo Panic! $< exists, but $@ does not.; \\\n\t    exit 1; \\\n\telse exit 0 ; \\\n\tfi\n\nshow:\n\t@echo '$(VALUE)=\"$($(VALUE))\"'\n\nclean ::\n\t$(RM) $(HS_OBJS) $(STUBOBJS) $(C_OBJS) $(LIB) $(GHCI_LIB) $(HS_IFS) .depend\n\t$(RM) -rf $(wildcard $(patsubst %.$(osuf), %_split, $(HS_OBJS)))\n\nifneq \"$(strip $(WAYS))\" \"\"\nifeq \"$(way)\" \"\"\nall clean ::\n# Don't rely on -e working, instead we check exit return codes from sub-makes.\n\t@case '${MFLAGS}' in *-[ik]*) x_on_err=0;; *-r*[ik]*) x_on_err=0;; *) x_on_err=1;; esac; \\\n\tfor i in $(WAYS) ; do \\\n\t  echo \"== $(MAKE) way=$$i -f $(MAKEFILE) $@;\"; \\\n\t  $(MAKE) way=$$i -f $(MAKEFILE) --no-print-directory $(MFLAGS) $@ ; \\\n\t  if [ $$? -eq 0 ] ; then true; else exit $$x_on_err; fi; \\\n\tdone\n\t@echo \"== Finished recursively making \\`$@' for ways: $(WAYS) ...\"\nendif\nendif\n"
:: String }
