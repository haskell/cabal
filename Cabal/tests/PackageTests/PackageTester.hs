{-# LANGUAGE ScopedTypeVariables #-}

-- You can set the following VERBOSE environment variable to control
-- the verbosity of the output generated by this module.
module PackageTests.PackageTester
    ( PackageSpec(..)
    , SuiteConfig(..)
    , Success(..)
    , Result(..)

    -- * Running cabal commands
    , cabal_configure
    , cabal_build
    , cabal_haddock
    , cabal_test
    , cabal_bench
    , cabal_install
    , cabal_register
    , unregister
    , compileSetup
    , run

    -- * Test helpers
    , assertConfigureSucceeded
    , assertBuildSucceeded
    , assertBuildFailed
    , assertHaddockSucceeded
    , assertTestSucceeded
    , assertTestFailed
    , assertInstallSucceeded
    , assertRegisterSucceeded
    , assertRegisterFailed
    , assertOutputContains
    , assertOutputDoesNotContain
    ) where

import qualified Control.Exception.Extensible as E
import Control.Monad
import qualified Data.ByteString.Char8 as C
import Data.List
import Data.Maybe
import System.Directory (canonicalizePath, doesFileExist)
import System.Environment (getEnv)
import System.Exit (ExitCode(ExitSuccess))
import System.FilePath
import System.IO (hIsEOF, hGetChar, hClose)
import System.IO.Error (isDoesNotExistError)
import System.Process (runProcess, waitForProcess)
import Test.Tasty.HUnit (Assertion, assertFailure)

import Distribution.Compat.CreatePipe (createPipe)
import Distribution.Simple.BuildPaths (exeExtension)
import Distribution.Simple.Compiler (PackageDBStack, PackageDB(..))
import Distribution.Simple.Program.Run (getEffectiveEnvironment)
import Distribution.Simple.Utils (printRawCommandAndArgsAndEnv)
import Distribution.ReadE (readEOrFail)
import Distribution.Verbosity (Verbosity, flagToVerbosity, normal)

data PackageSpec = PackageSpec
    { directory  :: FilePath
    , distPref :: Maybe FilePath
    , configOpts :: [String]
    }

data SuiteConfig = SuiteConfig
    { ghcPath :: FilePath
    , ghcPkgPath :: FilePath
    , cabalDistPref :: FilePath
    , inplaceSpec :: PackageSpec
    , packageDBStack :: PackageDBStack
    }

data Success = Failure
             | ConfigureSuccess
             | BuildSuccess
             | HaddockSuccess
             | InstallSuccess
             | RegisterSuccess
             | TestSuccess
             | BenchSuccess
             deriving (Eq, Show)

data Result = Result
    { successful :: Bool
    , success    :: Success
    , outputText :: String
    } deriving Show

nullResult :: Result
nullResult = Result True Failure ""

------------------------------------------------------------------------
-- * Running cabal commands

recordRun :: (String, ExitCode, String) -> Success -> Result -> Result
recordRun (cmd, exitCode, exeOutput) thisSucc res =
    res { successful = successful res && exitCode == ExitSuccess
        , success    = if exitCode == ExitSuccess then thisSucc
                       else success res
        , outputText =
            (if null $ outputText res then "" else outputText res ++ "\n") ++
            cmd ++ "\n" ++ exeOutput
        }

cabal_configure :: SuiteConfig -> PackageSpec -> IO Result
cabal_configure config spec = do
    res <- doCabalConfigure config spec
    record spec res
    return res

doCabalConfigure :: SuiteConfig -> PackageSpec -> IO Result
doCabalConfigure config spec = do
    cleanResult@(_, _, _) <- cabal config spec [] ["clean"]
    requireSuccess cleanResult
    res <- cabal config spec []
           -- Use the package dbs from when we configured cabal rather than any
           -- defaults.
           (["configure", "--user", "-w", ghcPath config, "--package-db=clear"]
            ++ packageDBParams (packageDBStack config)
            ++ configOpts spec)
    return $ recordRun res ConfigureSuccess nullResult

packageDBParams :: PackageDBStack -> [String]
packageDBParams = map (("--package-db=" ++) . convert) where
    convert :: PackageDB -> String
    convert  GlobalPackageDB         = "global"
    convert  UserPackageDB           = "user"
    convert (SpecificPackageDB path) = path

doCabalBuild :: SuiteConfig -> PackageSpec -> IO Result
doCabalBuild config spec = do
    configResult <- doCabalConfigure config spec
    if successful configResult
        then do
            res <- cabal config spec [] ["build", "-v"]
            return $ recordRun res BuildSuccess configResult
        else
            return configResult

cabal_build :: SuiteConfig -> PackageSpec -> IO Result
cabal_build config spec = do
    res <- doCabalBuild config spec
    record spec res
    return res

cabal_haddock :: SuiteConfig -> PackageSpec -> [String] -> IO Result
cabal_haddock config spec extraArgs = do
    res <- doCabalHaddock config spec extraArgs
    record spec res
    return res

doCabalHaddock :: SuiteConfig -> PackageSpec -> [String] -> IO Result
doCabalHaddock config spec extraArgs = do
    configResult <- doCabalConfigure config spec
    if successful configResult
        then do
            res <- cabal config spec [] ("haddock" : extraArgs)
            return $ recordRun res HaddockSuccess configResult
        else
            return configResult

unregister :: SuiteConfig -> String -> IO ()
unregister config libraryName = do
    res@(_, _, output) <- run Nothing (ghcPkgPath config) []
                          ["unregister", "--user", libraryName]
    if "cannot find package" `isInfixOf` output
        then return ()
        else requireSuccess res

-- | Install this library in the user area
cabal_install :: SuiteConfig -> PackageSpec -> IO Result
cabal_install config spec = do
    buildResult <- doCabalBuild config spec
    res <- if successful buildResult
        then do
            res <- cabal config spec [] ["install"]
            return $ recordRun res InstallSuccess buildResult
        else
            return buildResult
    record spec res
    return res

cabal_register :: SuiteConfig -> PackageSpec -> [String] -> IO Result
cabal_register config spec extraArgs = do
    res <- doCabalRegister config spec extraArgs
    record spec res
    return res

doCabalRegister :: SuiteConfig -> PackageSpec -> [String] -> IO Result
doCabalRegister config spec extraArgs = do
    configResult <- doCabalConfigure config spec
    if successful configResult
        then do
            buildResult <- doCabalBuild config spec
            if successful buildResult
              then do res <- cabal config spec [] ("register" : extraArgs)
                      return $ recordRun res RegisterSuccess configResult
              else return buildResult
        else
            return configResult


cabal_test :: SuiteConfig -> PackageSpec -> [(String, Maybe String)]
           -> [String] -> IO Result
cabal_test config spec envOverrides extraArgs = do
    res <- cabal config spec envOverrides ("test" : extraArgs)
    let r = recordRun res TestSuccess nullResult
    record spec r
    return r

cabal_bench :: SuiteConfig -> PackageSpec -> [String] -> IO Result
cabal_bench config spec extraArgs = do
    res <- cabal config spec [] ("bench" : extraArgs)
    let r = recordRun res BenchSuccess nullResult
    record spec r
    return r

compileSetup :: SuiteConfig -> FilePath -> IO ()
compileSetup config packageDir = do
    r <- run (Just $ packageDir) (ghcPath config) []
         [ "--make"
-- HPC causes trouble -- see #1012
--       , "-fhpc"
         , "-package-conf " ++ (cabalDistPref config) </> "package.conf.inplace"
         , "Setup.hs"
         ]
    requireSuccess r

-- | Returns the command that was issued, the return code, and the output text.
cabal :: SuiteConfig
      -> PackageSpec
      -> [(String, Maybe String)]  -- ^ environment variable overrides
      -> [String]  -- ^ extra arguments
      -> IO (String, ExitCode, String)
cabal config spec envOverrides cabalArgs_ = do
    let cabalArgs = case distPref spec of
                       Nothing -> cabalArgs_
                       Just dist -> ("--builddir=" ++ dist) : cabalArgs_
    customSetup <- doesFileExist (directory spec </> "Setup.hs")
    if customSetup
        then do
            compileSetup config (directory spec)
            path <- canonicalizePath $ directory spec </> "Setup"
            run (Just $ directory spec) path envOverrides cabalArgs
        else do
            -- Use shared Setup executable (only for Simple build types).
            path <- canonicalizePath "Setup"
            run (Just $ directory spec) path envOverrides cabalArgs

-- | Returns the command that was issued, the return code, and the output text
run :: Maybe FilePath -> String -> [(String, Maybe String)] -> [String] -> IO (String, ExitCode, String)
run cwd path envOverrides args = do
    verbosity <- getVerbosity
    -- path is relative to the current directory; canonicalizePath makes it
    -- absolute, so that runProcess will find it even when changing directory.
    path' <- do pathExists <- doesFileExist path
                canonicalizePath (if pathExists then path else path <.> exeExtension)
    menv <- getEffectiveEnvironment envOverrides

    printRawCommandAndArgsAndEnv verbosity path' args menv
    (readh, writeh) <- createPipe
    pid <- runProcess path' args cwd menv Nothing (Just writeh) (Just writeh)

    -- fork off a thread to start consuming the output
    out <- suckH [] readh
    hClose readh

    -- wait for the program to terminate
    exitcode <- waitForProcess pid
    let fullCmd = unwords (path' : args)
    return ("\"" ++ fullCmd ++ "\" in " ++ fromMaybe "" cwd, exitcode, out)
  where
    suckH output h = do
        eof <- hIsEOF h
        if eof
            then return (reverse output)
            else do
                c <- hGetChar h
                suckH (c:output) h


requireSuccess :: (String, ExitCode, String) -> IO ()
requireSuccess (cmd, exitCode, output) =
    unless (exitCode == ExitSuccess) $
        assertFailure $ "Command " ++ cmd ++ " failed.\n" ++
        "output: " ++ output

record :: PackageSpec -> Result -> IO ()
record spec res = do
    C.writeFile (directory spec </> "test-log.txt") (C.pack $ outputText res)

------------------------------------------------------------------------
-- * Test helpers

assertConfigureSucceeded :: Result -> Assertion
assertConfigureSucceeded result = unless (successful result) $
    assertFailure $
    "expected: \'setup configure\' should succeed\n" ++
    "  output: " ++ outputText result

assertBuildSucceeded :: Result -> Assertion
assertBuildSucceeded result = unless (successful result) $
    assertFailure $
    "expected: \'setup build\' should succeed\n" ++
    "  output: " ++ outputText result

assertBuildFailed :: Result -> Assertion
assertBuildFailed result = when (successful result) $
    assertFailure $
    "expected: \'setup build\' should fail\n" ++
    "  output: " ++ outputText result

assertHaddockSucceeded :: Result -> Assertion
assertHaddockSucceeded result = unless (successful result) $
    assertFailure $
    "expected: \'setup haddock\' should succeed\n" ++
    "  output: " ++ outputText result

assertTestSucceeded :: Result -> Assertion
assertTestSucceeded result = unless (successful result) $
    assertFailure $
    "expected: \'setup test\' should succeed\n" ++
    "  output: " ++ outputText result

assertTestFailed :: Result -> Assertion
assertTestFailed result = when (successful result) $
    assertFailure $
    "expected: \'setup test\' should fail\n" ++
    "  output: " ++ outputText result

assertInstallSucceeded :: Result -> Assertion
assertInstallSucceeded result = unless (successful result) $
    assertFailure $
    "expected: \'setup install\' should succeed\n" ++
    "  output: " ++ outputText result

assertRegisterSucceeded :: Result -> Assertion
assertRegisterSucceeded result = unless (successful result) $
    assertFailure $
    "expected: \'setup register\' should succeed\n" ++
    "  output: " ++ outputText result

assertRegisterFailed :: Result -> Assertion
assertRegisterFailed result = when (successful result) $
    assertFailure $
    "expected: \'setup register\' should fail\n" ++
    "  output: " ++ outputText result


assertOutputContains :: String -> Result -> Assertion
assertOutputContains needle result =
    unless (needle `isInfixOf` (concatOutput output)) $
    assertFailure $
    " expected: " ++ needle ++ "\n" ++
    " in output: " ++ output ++ ""
  where output = outputText result

assertOutputDoesNotContain :: String -> Result -> Assertion
assertOutputDoesNotContain needle result =
    when (needle `isInfixOf` (concatOutput output)) $
    assertFailure $
    "unexpected: " ++ needle ++
    " in output: " ++ output
  where output = outputText result

-- | Replace line breaks with spaces, correctly handling "\r\n".
concatOutput :: String -> String
concatOutput = unwords . lines . filter ((/=) '\r')

------------------------------------------------------------------------
-- Verbosity

lookupEnv :: String -> IO (Maybe String)
lookupEnv name =
    (fmap Just $ getEnv name)
    `E.catch` \ (e :: IOError) ->
        if isDoesNotExistError e
        then return Nothing
        else E.throw e

-- TODO: Convert to a "-v" flag instead.
getVerbosity :: IO Verbosity
getVerbosity = do
    maybe normal (readEOrFail flagToVerbosity) `fmap` lookupEnv "VERBOSE"
